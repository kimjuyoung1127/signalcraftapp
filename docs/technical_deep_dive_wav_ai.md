# 🛠️ SignalCraft 기술 심층 분석: WAV 파이프라인 & AI 로직 튜닝

**작성일**: 2025-11-29
**버전**: v1.0
**관련 Phase**: Phase D-2 ~ D-4

이 문서는 SignalCraft Mobile 프로젝트의 핵심 기능인 **오디오 분석 파이프라인 고도화**와 **AI 진단 로직 튜닝** 과정을 기술적으로 깊이 있게 다룹니다. 개발 과정에서의 의사결정 배경, 직면했던 문제, 그리고 해결책을 학습 목적으로 정리했습니다.

---

## 1. 🌊 WAV 오디오 파이프라인 (The Pipeline)

### 1.1 배경: 왜 WAV인가?
초기 구현에서는 플랫폼 기본 코덱(M4A/AAC 등)을 사용했습니다. 하지만 산업용 정밀 진단을 위해서는 **무손실(Lossless) 데이터**와 **넓은 주파수 대역(High Bandwidth)**이 필수적입니다.

*   **목표**: 10kHz 이상의 고주파 대역(High Frequency)을 분석하여 베어링의 초기 결함을 포착한다.
*   **제약**:
    *   **iOS**: WAV(Linear PCM) 녹음을 네이티브로 잘 지원함.
    *   **Android**: `expo-av` 라이브러리에서 WAV 녹음이 불안정하거나 파일 크기가 비정상적으로 커지는 이슈 존재.

### 1.2 아키텍처: Hybrid Recording & Server-side Conversion
우리는 **"클라이언트는 안정성, 서버는 품질"**이라는 전략을 택했습니다.

1.  **Android (안정성 우선)**:
    *   `M4A (AAC)` 포맷으로 녹음.
    *   단, **샘플 레이트(Sample Rate)를 44.1kHz**로 설정하여 22kHz 대역까지의 데이터를 보존 (압축 손실은 감수).
2.  **iOS (품질 우선)**:
    *   `WAV (Linear PCM)` 포맷으로 녹음.
    *   **44.1kHz, 16-bit** 무손실 데이터 전송.
3.  **Backend (통일성)**:
    *   업로드된 파일이 M4A든 WAV든 상관없이, **`AudioConverter` 모듈**이 `ffmpeg`를 사용하여 **무조건 44.1kHz WAV로 변환**합니다.
    *   AI 엔진(`Librosa`)은 항상 WAV 포맷만 처리하면 되므로 로직이 단순해집니다.

```python
# app/features/audio_analysis/converter.py 핵심 로직
def _convert_m4a_to_wav(input_path):
    cmd = [
        'ffmpeg', '-i', str(input_path),
        '-ar', '44100',  # 44.1kHz 리샘플링
        '-ac', '1',      # 모노 채널
        '-f', 'wav',     # WAV 포맷 강제
        str(output_path)
    ]
    # ... subprocess 실행
```

---

## 2. 🧠 Kaggle 데이터 검증 & AI 로직 튜닝

### 2.1 데이터의 실체 (The Reality Check)
우리가 확보한 `SUBF v2.0` 베어링 고장 데이터셋은 오디오 파일(`.wav`)이 아니라 **시계열 센서 데이터(`.csv`)**였습니다.

*   **도전**: `Librosa`는 오디오 파일 분석 라이브러리인데, 입력은 CSV 텍스트 파일임.
*   **해결 (Data Augmentation)**: CSV 데이터를 읽어 **"가상 WAV(Synthetic WAV)"**를 생성하는 스크립트(`convert_csv_to_wav.py`)를 개발했습니다.

### 2.2 Global Normalization의 중요성
첫 번째 변환 시도에서는 **개별 파일 기준**으로 정규화(-1.0 ~ 1.0)를 했습니다.
*   **문제**: 정상(Normal) 데이터는 진동이 작아야 하는데, 정규화 과정에서 작은 진동이 1.0(최대 볼륨)으로 증폭되어 **"엄청 시끄러운 정상 데이터"**가 되었습니다. -> **오진율 100%**
*   **해결**: 전체 데이터셋의 **절대 최대값(Global Max Value)**을 찾아, 모든 파일을 이 값으로 나누어 정규화했습니다.
    *   결과: 정상 데이터는 조용해지고, 고장 데이터는 시끄러운 상태가 유지됨.

### 2.3 튜닝의 기술 (The Art of Tuning)
AI 로직(`analyzer.py`)을 3차례에 걸쳐 튜닝하며 **Rule-based AI**의 정밀도를 높였습니다.

#### **1차 시도: 단순 RMS (에너지) 기준**
*   로직: `RMS > 0.2`면 CRITICAL.
*   결과: 모든 데이터가 0.4 이상이라 전부 CRITICAL로 오진.

#### **2차 시도: 주파수 대역(Band) 도입**
*   로직: 2k~10kHz 대역의 에너지 비율(`Resonance Ratio`)을 도입.
*   결과: Normal 데이터(`Ratio 0.32`)와 Fault 데이터(`Ratio 0.36~0.39`)의 미세한 차이를 발견.

#### **3차 튜닝 (Final): 정밀 임계값 설정**
데이터의 통계적 특성을 분석하여 임계값을 '수술'하듯 정밀하게 설정했습니다.

| 지표 (Metric) | Normal (Avg) | Fault (Avg) | 설정된 임계값 (Threshold) | 판정 |
| :--- | :--- | :--- | :--- | :--- |
| **Resonance Ratio** | **0.32** | **0.36 ~ 0.39** | **> 0.33** | **WARNING** |
| **Resonance Ratio** | - | **0.39+** | **> 0.39** | **CRITICAL** |
| **RMS (Noise)** | 0.47 | 0.46 | > 0.80 | (보조 지표로 격하) |

*   **결과**: Normal 100%, Inner Fault 100%, Outer Fault 100% 분류 성공.

---

## 3. 🏆 골든 샘플 기반 데모 (Golden Sample Engineering)

### 3.1 개념
데모 시연 시 **"랜덤 가짜 데이터"**를 보여주는 것은 신뢰도를 떨어뜨립니다. 우리는 **"검증된 실제 데이터(골든 샘플)"**의 분석 결과를 데모 시나리오에 주입하는 방식을 택했습니다.

### 3.2 구현 방식
1.  **선정**: 튜닝 과정에서 가장 특징이 뚜렷한 파일 3개를 선정 (`S_N(1).wav`, `S_IR(1).wav`, `S_OR(100).wav`).
2.  **통합**: `demo_payloads.py`가 `analyzer.py`를 직접 호출하여, 이 골든 샘플들을 실시간으로 분석한 결과값을 반환하도록 함.
3.  **시각화**: 프론트엔드 차트(`EnsembleRadar`)가 하드코딩된 모델명(`CNN`, `SVM`) 대신, 백엔드가 보낸 실제 분석 지표(`Librosa-RMS`, `Librosa-Resonance`)를 동적으로 렌더링하도록 수정.

### 3.3 기술적 이슈 & 해결 (Troubleshooting)
*   **NumPy 직렬화 에러**: `analyzer.py`가 반환하는 `numpy.float32` 타입은 JSON으로 변환되지 않아 서버 에러 발생.
    *   -> **해결**: 모든 반환 값을 `float()`으로 명시적 캐스팅.
*   **데모 모드에서의 API 에러**: 오프라인이거나 인증 토큰이 없을 때 데모가 깨짐.
    *   -> **해결**: `AnalysisService`에서 데모 모드(`MOCK-` ID) 감지 시, **API 호출을 원천 차단하고 로컬 목업 데이터를 즉시 반환**하도록 로직 강화.

---

## 4. 🚀 결론 및 교훈

이번 작업을 통해 SignalCraft Mobile은 단순한 UI 껍데기가 아닌, **실제 데이터 파이프라인과 분석 로직이 살아있는 MVP**로 진화했습니다.

1.  **데이터가 답이다**: 로직 튜닝은 상상이 아니라 **데이터의 통계적 분석**을 통해 이루어져야 합니다.
2.  **하이브리드 전략**: 현실적인 제약(모바일 녹음 품질)과 이상적인 목표(고품질 분석) 사이에서, **플랫폼별 최적화 + 서버 통합**이라는 유연한 아키텍처가 유효했습니다.
3.  **데모도 엔지니어링이다**: 단순히 보여주기 위한 데모가 아니라, 실제 기술을 검증하고 그 결과를 보여주는 데모가 훨씬 강력합니다.
